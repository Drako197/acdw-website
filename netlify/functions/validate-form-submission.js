
// Import utilities
const { checkRateLimit, getRateLimitHeaders, getClientIP } = require('./utils/rate-limiter')
const { sanitizeFormData } = require('./utils/input-sanitizer')
const { getSecurityHeaders } = require('./utils/cors-config')
const { 
  logFormSubmission, 
  logBotDetected, 
  logRecaptcha, 
  logRateLimit, 
  logInjectionAttempt,
  EVENT_TYPES 
} = require('./utils/security-logger')

const { validateRequestFingerprint } = require('./utils/request-fingerprint')
const { validateIP, addToBlacklist } = require('./utils/ip-reputation')
const { validateSubmissionBehavior } = require('./utils/behavioral-analysis')
const { validateEmailDomain } = require('./utils/email-domain-validator')
const { validateCSRFToken } = require('./utils/csrf-validator')
const { initBlobsStores } = require('./utils/blobs-store')


const RECAPTCHA_SECRET_KEY = process.env.RECAPTCHA_SECRET_KEY

const verifyRecaptcha = async (token) => {
  if (!RECAPTCHA_SECRET_KEY) {
    console.warn('reCAPTCHA secret key not configured - skipping verification')
    return { success: false, score: 0, error: 'Not configured' }
  }

  try {
    const response = await fetch('https://www.google.com/recaptcha/api/siteverify', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        secret: RECAPTCHA_SECRET_KEY,
        response: token
      }).toString()
    })

    const data = await response.json()
    return {
      success: data.success || false,
      score: data.score || 0,
      action: data.action || '',
      challenge_ts: data.challenge_ts,
      hostname: data.hostname,
      'error-codes': data['error-codes'] || []
    }
  } catch (error) {
    console.error('reCAPTCHA verification error:', error)
    return { success: false, score: 0, error: error.message }
  }
}

const validateEmail = (email) => {
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/
  const trimmedEmail = email?.trim() || ''
  
  if (!trimmedEmail) {
    return { valid: false, error: 'Email is required' }
  }
  
  if (!emailRegex.test(trimmedEmail)) {
    return { valid: false, error: 'Invalid email format' }
  }
  
  return { valid: true, email: trimmedEmail }
}

const validateFormFields = (formType, formData) => {
  const errors = []
  
  // Handle contact form subtypes (contact-general, contact-support, contact-sales, contact-installer, contact-demo)
  if (formType.startsWith('contact-')) {
    const contactSubType = formType.replace('contact-', '')
    const firstName = formData.get('firstName')?.trim() || ''
    const lastName = formData.get('lastName')?.trim() || ''
    const message = formData.get('message')?.trim() || ''
    
    // Common fields for all contact forms
    if (!firstName) errors.push('First name is required')
    if (!lastName) errors.push('Last name is required')
    if (!message) errors.push('Message is required')
    if (message && message.length > 2000) {
      errors.push('Message must be 2000 characters or less')
    }
    
    // Form-specific required fields
    switch (contactSubType) {
      case 'support':
        // Support form requires: product, issueType
        const product = formData.get('product')?.trim() || ''
        const issueType = formData.get('issueType')?.trim() || ''
        if (!product) errors.push('Product is required')
        if (!issueType) errors.push('Issue type is required')
        break
        
      case 'sales':
        // Sales form requires: company, role, interest
        const company = formData.get('company')?.trim() || ''
        const role = formData.get('role')?.trim() || ''
        const interest = formData.get('interest')?.trim() || ''
        if (!company) errors.push('Company is required')
        if (!role) errors.push('Role is required')
        if (!interest) errors.push('Interest type is required')
        break
        
      case 'installer':
        // Installer form requires: location, productToInstall
        const location = formData.get('location')?.trim() || ''
        const productToInstall = formData.get('productToInstall')?.trim() || ''
        if (!location) errors.push('Location is required')
        if (!productToInstall) errors.push('Product to install is required')
        break
        
      case 'demo':
        // Demo form requires: company, demoType, city, state, zip, numberOfAttendees, productsOfInterest
        const demoCompany = formData.get('company')?.trim() || ''
        const demoType = formData.get('demoType')?.trim() || ''
        const demoCity = formData.get('city')?.trim() || ''
        const demoState = formData.get('state')?.trim() || ''
        const demoZip = formData.get('zip')?.trim() || ''
        const numberOfAttendees = formData.get('numberOfAttendees')?.trim() || ''
        const productsOfInterest = formData.get('productsOfInterest')?.trim() || ''
        if (!demoCompany) errors.push('Company is required')
        if (!demoType) errors.push('Demo type is required')
        if (!demoCity) errors.push('City is required')
        if (!demoState) errors.push('State is required')
        if (!demoZip) errors.push('ZIP code is required')
        if (demoZip && !/^\d{5}$/.test(demoZip)) {
          errors.push('ZIP code must be 5 digits')
        }
        if (!numberOfAttendees) errors.push('Number of attendees is required')
        if (!productsOfInterest) errors.push('At least one product of interest is required')
        break
        
      case 'general':
        // General form - no additional required fields beyond common ones
        break
        
      default:
        console.warn(`Unknown contact form subtype: ${contactSubType}`)
    }
  } else {
    // Handle other form types
    switch (formType) {
      case 'hero-email':
      case 'promo':
        // Email-only forms - email validation handled separately
        break
        
      case 'upgrade':
        // Core 1.0 upgrade form requires: firstName, lastName, email, phone, street, city, state, zip, consent, photoUrl
        const upgradeFirstName = formData.get('firstName')?.trim() || ''
        const upgradeLastName = formData.get('lastName')?.trim() || ''
        const upgradeEmail = formData.get('email')?.trim() || ''
        const upgradePhone = formData.get('phone')?.trim() || ''
        const upgradeStreet = formData.get('street')?.trim() || ''
        const upgradeCity = formData.get('city')?.trim() || ''
        const upgradeState = formData.get('state')?.trim() || ''
        const upgradeZip = formData.get('zip')?.trim() || ''
        const upgradeConsent = formData.get('consent')
        const upgradePhotoUrl = formData.get('photoUrl')?.trim() || '' // Now expecting URL instead of file
        
        if (!upgradeFirstName) errors.push('First name is required')
        if (!upgradeLastName) errors.push('Last name is required')
        if (!upgradeEmail) {
          errors.push('Email is required')
        } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(upgradeEmail)) {
          errors.push('Invalid email format')
        }
        if (!upgradePhone) errors.push('Phone is required')
        if (!upgradeStreet) errors.push('Street address is required')
        if (!upgradeCity) errors.push('City is required')
        if (!upgradeState) errors.push('State is required')
        if (!upgradeZip) {
          errors.push('ZIP code is required')
        } else if (!/^\d{5}$/.test(upgradeZip)) {
          errors.push('ZIP code must be 5 digits')
        }
        if (!upgradeConsent || upgradeConsent !== 'yes') {
          errors.push('You must acknowledge the terms to continue')
        }
        if (!upgradePhotoUrl) {
          errors.push('Photo is required. Please upload a photo of your installed Core 1.0.')
        } else if (!upgradePhotoUrl.startsWith('data:image/') && !upgradePhotoUrl.startsWith('https://res.cloudinary.com/')) {
          // Validate that photoUrl is either a data URL or a Cloudinary URL
          errors.push('Invalid photo format. Please upload a valid image file.')
        }
        break
        
      case 'unsubscribe':
        // Unsubscribe form requires: email, reason (optional but must be valid if provided)
        const unsubscribeReason = formData.get('reason')?.trim() || ''
        if (unsubscribeReason) {
          // SECURITY: Validate dropdown value - prevent malformed email injection
          const ALLOWED_UNSUBSCRIBE_REASONS = [
            'too-many-emails',
            'not-relevant',
            'never-signed-up',
            'other'
          ]
          
          if (!ALLOWED_UNSUBSCRIBE_REASONS.includes(unsubscribeReason)) {
            // Check if reason looks like a malformed email (bot attack pattern)
            if (unsubscribeReason.includes('-') && !unsubscribeReason.includes('@')) {
              errors.push('Invalid reason selected - suspicious pattern detected')
              console.warn('üö® Bot attack detected: Malformed email in unsubscribe reason field', {
                reason: unsubscribeReason,
                ip: getClientIP ? getClientIP(event) : 'unknown'
              })
            } else {
              errors.push('Invalid reason selected')
            }
          }
        }
        break
        
      case 'email-preferences':
        // Email preferences form - email validation handled separately
        break
        
      default:
        console.warn(`Unknown form type: ${formType}`)
    }
  }
  
  return errors
}

exports.handler = async (event, context) => {
  // Initialize Blobs stores within handler context (required for Blobs to work)
  // This must be called inside the handler where Netlify context is available
  // Wrap in try-catch to prevent function crash if Blobs fails
  let blobsInit = { initialized: false }
  try {
    blobsInit = initBlobsStores(context)
  } catch (blobsError) {
    // Blobs initialization failed - log but continue (fail-open)
    console.warn('‚ö†Ô∏è Blobs initialization error (continuing with fallback):', blobsError.message)
  }
  
    const headers = getSecurityHeaders(event)

  // Handle CORS preflight
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers,
      body: '',
    }
  }

  // Only allow POST requests
  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
    }

    // Rate limiting
    const ip = getClientIP(event)
    const rateLimitResult = await checkRateLimit(ip, 'form', context)
    if (!rateLimitResult.allowed) {
        return {
            statusCode: 429,
            headers: {
                ...headers,
                ...getRateLimitHeaders(rateLimitResult)
            },
            body: JSON.stringify({
                error: 'Too many form submissions. Please wait and try again.',
                retryAfter: rateLimitResult.retryAfter
            }),
        }
    }

  try {
    // SECURITY: Check if this is a webhook endpoint (exempt from some validations)
    const isWebhookEndpoint = (path) => {
      return path && (path.includes('stripe-webhook') || path.includes('webhook'))
    }
    
    const isCheckoutEndpoint = (path) => {
      return path && (path.includes('create-checkout') || path.includes('get-checkout-session') || path.includes('get-price-id'))
    }
    
    const path = event.path || ''
    
    // Parse form data - all forms now use application/x-www-form-urlencoded
    // File uploads are handled separately via upload-file function
    const contentType = event.headers['content-type'] || event.headers['Content-Type'] || ''
    
    // Multipart should not be used anymore - files should be uploaded separately
    if (contentType.includes('multipart/form-data')) {
      console.warn('‚ö†Ô∏è Multipart form data received - this should not happen with new flow')
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ 
          error: 'Invalid form data format',
          message: 'Please use the standard form submission. File uploads should be handled separately.'
        }),
      }
    }
    
    // Parse as URLSearchParams (standard form data)
    const formData = new URLSearchParams(event.body)
    
    // Get form name and type
    const formName = formData.get('form-name') || ''
    const formType = formData.get('form-type') || 'contact'
    
    // SECURITY: Form name whitelist validation (only allow known form names)
    const ALLOWED_FORM_NAMES = [
      'contact-general',
      'contact-support',
      'contact-sales',
      'contact-installer',
      'contact-demo',
      'ep-x7k9m2',
      'unsubscribe',
      'promo-signup',
      'core-upgrade',
      'hero-email'
    ]
    
    // Only validate form name if this is a form submission (not a webhook or checkout endpoint)
    if (!isWebhookEndpoint(path) && !isCheckoutEndpoint(path)) {
      if (formName && !ALLOWED_FORM_NAMES.includes(formName)) {
        console.warn('‚ùå Invalid form name rejected:', {
          formName,
          ip: getClientIP(event),
          userAgent: event.headers['user-agent'] || 'unknown',
          path
        })
        logBotDetected(formType, 'invalid-form-name', getClientIP(event), event.headers['user-agent'] || 'unknown', {
          formName,
          allowedNames: ALLOWED_FORM_NAMES
        })
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({ 
            error: 'Invalid form name',
            message: 'Form submission rejected'
          }),
        }
      }
    }
    
    // SECURITY: Origin/Referer validation (exempt webhooks and checkout endpoints)
    if (!isWebhookEndpoint(path) && !isCheckoutEndpoint(path)) {
      const ALLOWED_ORIGINS = [
        'https://www.acdrainwiz.com',
        'https://acdrainwiz.com'
      ]
      
      const origin = event.headers.origin || event.headers.referer || ''
      const isValidOrigin = !origin || ALLOWED_ORIGINS.some(allowed => origin.startsWith(allowed))
      
      if (!isValidOrigin) {
        console.warn('‚ùå Invalid origin rejected:', {
          origin,
          ip: getClientIP(event),
          userAgent: event.headers['user-agent'] || 'unknown',
          path
        })
        logBotDetected(formType, 'invalid-origin', getClientIP(event), event.headers['user-agent'] || 'unknown', {
          origin,
          allowedOrigins: ALLOWED_ORIGINS
        })
        return {
          statusCode: 403,
          headers,
          body: JSON.stringify({ 
            error: 'Invalid origin',
            message: 'Request rejected'
          }),
        }
      }
    }
    
    // SECURITY: User-Agent validation (exempt webhooks)
    if (!isWebhookEndpoint(path)) {
      const BOT_USER_AGENTS = [
        'curl',
        'wget',
        'python-requests',
        'go-http-client',
        'java/',
        'scrapy',
        'bot',
        'crawler',
        'spider',
        'httpie',
        'postman'
      ]
      
      const userAgent = event.headers['user-agent'] || ''
      const isBotUserAgent = BOT_USER_AGENTS.some(bot => userAgent.toLowerCase().includes(bot.toLowerCase()))
      
      if (isBotUserAgent) {
        console.warn('‚ùå Bot user agent rejected:', {
          userAgent,
          ip: getClientIP(event),
          path
        })
        logBotDetected(formType, 'bot-user-agent', getClientIP(event), userAgent, {
          userAgent,
          detectedBots: BOT_USER_AGENTS.filter(bot => userAgent.toLowerCase().includes(bot.toLowerCase()))
        })
        return {
          statusCode: 403,
          headers,
          body: JSON.stringify({ 
            error: 'Bot detected',
            message: 'Request rejected'
          }),
        }
      }
    }
    
    // Get honeypot fields (field names may vary by form)
    const botField = formData.get('bot-field') || formData.get('website') || formData.get('url') || ''
    const honeypot1 = formData.get('honeypot-1') || ''
    const honeypot2 = formData.get('honeypot-2') || ''
    
    // Get reCAPTCHA token
    const recaptchaToken = formData.get('recaptcha-token') || ''
    
    // Get email for validation (before sanitization)
    const rawEmail = formData.get('email') || ''
    
    // Get request metadata for logging
    const ip = getClientIP(event)
    const userAgent = event.headers['user-agent'] || 'unknown'
    const origin = event.headers['origin'] || event.headers['referer'] || 'unknown'
    
    // ============================================
    // PHASE 1: Request Fingerprinting
    // ============================================
    // Only apply to form endpoints (not webhooks/checkout)
    if (!isWebhookEndpoint(path) && !isCheckoutEndpoint(path)) {
      try {
        const fingerprintCheck = validateRequestFingerprint(event, ip, userAgent)
        if (fingerprintCheck.isBot) {
          logBotDetected(formType, 'request-fingerprint-failed', ip, userAgent, {
            reason: fingerprintCheck.reason,
            details: fingerprintCheck.details,
            formName
          })
          // Return success to bot (honeypot technique)
          return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ 
              success: true,
              message: 'Form submitted successfully'
            }),
          }
        }
      } catch (fingerprintError) {
        // Fail open - allow if check fails
        console.error('Fingerprint check error:', fingerprintError.message)
      }
    }
    
    // ============================================
    // PHASE 2: IP Reputation & Blacklist
    // ============================================
    // Only apply to form endpoints (not webhooks/checkout)
    if (!isWebhookEndpoint(path) && !isCheckoutEndpoint(path)) {
      try {
        const ipValidation = await validateIP(ip, userAgent, formType)
        if (!ipValidation.allowed) {
          logBotDetected(formType, 'ip-validation-failed', ip, userAgent, {
            reason: ipValidation.reason,
            details: ipValidation.details,
            formName
          })
          // Return success to bot (honeypot technique)
          return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ 
              success: true,
              message: 'Form submitted successfully'
            }),
          }
        }
      } catch (ipCheckError) {
        // Fail open - allow if check fails
        console.error('IP validation error:', ipCheckError.message)
      }
    }
    
    const BOT_USER_AGENTS = [
      'curl', 'wget', 'python-requests', 'python', 'go-http-client',
      'java/', 'scrapy', 'bot', 'crawler', 'spider', 'headless',
      'phantom', 'selenium', 'postman', 'insomnia', 'httpie'
    ]
    
    const lowerUserAgent = userAgent.toLowerCase()
    if (BOT_USER_AGENTS.some(bot => lowerUserAgent.includes(bot))) {
      logBotDetected(formType, 'bot-user-agent', ip, userAgent, {
        detectedPattern: BOT_USER_AGENTS.find(bot => lowerUserAgent.includes(bot)),
        formName
      })
      console.warn('üö´ Bot detected: User-Agent match', {
        userAgent,
        ip,
        formType,
        formName
      })
      // Return success to bot to prevent detection, but don't forward to Netlify
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({ 
          success: true,
          message: 'Form submitted successfully'
        }),
      }
    }
    
    // SECURITY: Validate Origin/Referer (Phase 2 - Origin Validation)
    // Must be from our domain to prevent CSRF and direct POST attacks
    const ALLOWED_ORIGINS = [
      'https://www.acdrainwiz.com',
      'https://acdrainwiz.com',
      'http://localhost:5173', // Development
      'http://localhost:8888', // Netlify dev
    ]
    
    const hasValidOrigin = ALLOWED_ORIGINS.some(allowedOrigin => 
      origin.startsWith(allowedOrigin)
    )
    
    if (!hasValidOrigin && origin !== 'unknown') {
      logBotDetected(formType, 'invalid-origin', ip, userAgent, {
        origin,
        allowedOrigins: ALLOWED_ORIGINS,
        formName
      })
      console.warn('üö´ Bot detected: Invalid origin', {
        origin,
        ip,
        userAgent,
        formType,
        formName
      })
      // Return success to bot to prevent detection, but don't forward to Netlify
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({ 
          success: true,
          message: 'Form submitted successfully'
        }),
      }
    }

    // Rate limiting check
    const rateLimitType = formType === 'upgrade' ? 'strict' : 'form'
    const rateLimitResult = await checkRateLimit(ip, rateLimitType, context)
    
    if (!rateLimitResult.allowed) {
      logRateLimit(ip, rateLimitType, rateLimitResult.limit, rateLimitResult.remaining, true)
      
      return {
        statusCode: 429,
        headers: {
          ...headers,
          ...getRateLimitHeaders(rateLimitResult)
        },
        body: JSON.stringify({
          success: false,
          error: 'Too many requests. Please try again later.',
          retryAfter: rateLimitResult.retryAfter
        })
      }
    }

    // Sanitize all text inputs (convert URLSearchParams to object for sanitization)
    const formDataObj = {}
    for (const [key, value] of formData.entries()) {
      // All values are strings now (no files - files converted to URLs on client)
      formDataObj[key] = String(value || '')
    }
    
    // Sanitize form data
    const sanitizedData = sanitizeFormData(formDataObj, formType)
    
    // Get sanitized email for validation
    const email = sanitizedData.email || rawEmail

    // Validation errors array
    const errors = []
    
    // 0. Verify reCAPTCHA token (if provided and configured)
    let recaptchaResult = null
    if (recaptchaToken) {
      recaptchaResult = await verifyRecaptcha(recaptchaToken)
      
      if (!recaptchaResult.success) {
        logRecaptcha(false, 0, recaptchaResult.action, ip, userAgent, recaptchaResult['error-codes'])
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({ 
            error: 'Security verification failed',
            message: 'Please refresh and try again'
          }),
        }
      }
      
      const scoreThreshold = formType === 'unsubscribe' 
        ? parseFloat(process.env.RECAPTCHA_SCORE_THRESHOLD || '0.7')
        : parseFloat(process.env.RECAPTCHA_SCORE_THRESHOLD || '0.5')
      
      if (recaptchaResult.score < scoreThreshold) {
        logRecaptcha(true, recaptchaResult.score, recaptchaResult.action, ip, userAgent)
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({ 
            error: 'Suspicious activity detected',
            message: 'Please try again'
          }),
        }
      }
      
      if (recaptchaResult.action) {

          const expectedAction = formType === 'unsubscribe' ? 'unsubscribe' : formType.replace(/-/g, '_')
        if (recaptchaResult.action !== expectedAction && recaptchaResult.action !== 'submit') {

            logBotDetected(formType, 'invalid-recaptcha-action', ip, userAgent, {
            expected: expectedAction,
            received: recaptchaResult.action,
            formName
          })

        }
      }
      
      logRecaptcha(true, recaptchaResult.score, recaptchaResult.action, ip, userAgent)
    } else if (RECAPTCHA_SECRET_KEY) {

        console.warn(' reCAPTCHA token missing (but configured)', {
        formType,
        ip,
        userAgent,
        email: email ? email.substring(0, 3) + '***' : 'none' 
      })

    }


      if (botField || honeypot1 || honeypot2) {
      logBotDetected(formType, 'honeypot', ip, userAgent, {
        botField: !!botField,
        honeypot1: !!honeypot1,
        honeypot2: !!honeypot2,
      })
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ 
          error: 'Invalid submission',
          message: 'Bot detected'
        }),
      }
    }


      const emailValidation = validateEmail(email)
    if (!emailValidation.valid) {
      errors.push(emailValidation.error)
    } else if (email && !isWebhookEndpoint(path) && !isCheckoutEndpoint(path)) {

        try {
        const domainValidation = await validateEmailDomain(email, ip, userAgent, formType)
        if (!domainValidation.valid) {
          logBotDetected(formType, 'email-domain-validation-failed', ip, userAgent, {
            reason: domainValidation.reason,
            details: domainValidation.details,
            formName
          })
          errors.push(domainValidation.details?.message || domainValidation.reason)
        }
      } catch (emailValidationError) {

            console.error('Email domain validation error:', emailValidationError.message)
      }
    }

      const formErrors = validateFormFields(formType, formData)
    errors.push(...formErrors)
    
    // SECURITY: Additional validation for unsubscribe form - dropdown value validation
    if (formType === 'unsubscribe' || formName === 'unsubscribe') {
      const unsubscribeReason = formData.get('reason')?.trim() || ''
      const unsubscribeEmail = formData.get('email')?.trim() || ''
      
      // Validate email format strictly - detect malformed email pattern
      const malformedEmailPattern = /^[a-z0-9]+-[a-z0-9]+-com$/i
      if (malformedEmailPattern.test(unsubscribeEmail)) {
        logBotDetected(formType, 'malformed-email-pattern', ip, userAgent, {
          email: unsubscribeEmail,
          formName
        })
        console.warn('üö® Bot attack detected: Malformed email pattern in email field', {
          email: unsubscribeEmail,
          ip,
          userAgent,
          formName
        })
        errors.push('Invalid email format')
      }
      
      // Validate reason dropdown
      if (unsubscribeReason) {
        const ALLOWED_UNSUBSCRIBE_REASONS = [
          'too-many-emails',
          'not-relevant',
          'never-signed-up',
          'spam',
          'privacy-concerns',
          'other'
        ]
        
        if (!ALLOWED_UNSUBSCRIBE_REASONS.includes(unsubscribeReason)) {
          // Check if reason looks like a malformed email (bot attack pattern)
          if (unsubscribeReason.includes('-') && !unsubscribeReason.includes('@') && unsubscribeReason.length > 10) {
            errors.push('Invalid reason selected - suspicious pattern detected')
            logBotDetected(formType, 'malformed-email-in-dropdown', ip, userAgent, {
              reason: unsubscribeReason,
              formName,
              email: rawEmail.substring(0, 20) + '***'
            })
            console.warn('üö® Bot attack detected: Malformed email in unsubscribe reason field', {
              reason: unsubscribeReason,
              formName,
              ip,
              userAgent
            })
          } else {
            errors.push('Invalid reason selected')
          }
        }
      }
    }

    // 4. Check for suspicious patterns
    if (email && !email.includes('@')) {
      errors.push('Invalid email format')
    }
    
    // ============================================
    // PHASE 3: Behavioral Analysis
    // ============================================
    // Only apply to form endpoints (not webhooks/checkout)
    if (!isWebhookEndpoint(path) && !isCheckoutEndpoint(path)) {
      const formLoadTime = formData.get('form-load-time')
      try {
        const behaviorValidation = await validateSubmissionBehavior(ip, email, formType, formLoadTime)
        if (!behaviorValidation.allowed) {
          logBotDetected(formType, 'behavioral-validation-failed', ip, userAgent, {
            reason: behaviorValidation.reason,
            details: behaviorValidation.details,
            formName
          })
          
          // Add to blacklist if suspicious
          await addToBlacklist(ip, behaviorValidation.reason, userAgent)
          
          // Return success to bot (honeypot technique)
          return {
            statusCode: 200,
            headers,
            body: JSON.stringify({ 
              success: true,
              message: 'Form submitted successfully'
            }),
          }
        }
      } catch (behaviorError) {
        // Fail open - allow if check fails
        console.error('Behavioral analysis error:', behaviorError.message)
      }
    }

    // If validation failed, reject
    if (errors.length > 0) {
      // SECURITY: Don't log full email - only log first 3 characters for debugging
      const emailPrefix = email ? email.substring(0, 3) + '***' : 'none'
      console.warn('‚ùå Validation failed:', {
        formType,
        errors,
        email: emailPrefix, // Sanitized - only first 3 chars
        ip,
        userAgent,
        formName
      })
      
      // Add to blacklist if multiple errors (likely bot)
      if (errors.length > 2 && !isWebhookEndpoint(path) && !isCheckoutEndpoint(path)) {
        await addToBlacklist(ip, `Multiple validation errors: ${errors.join(', ')}`, userAgent)
      }
      
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ 
          error: 'Validation failed',
          errors: errors
        }),
      }
    }

    // 5. If validation passed, forward sanitized data to Netlify Forms
    const netlifyFormUrl = event.headers.host 
      ? `https://${event.headers.host}/`
      : 'https://acdrainwiz.com/'
    
    // Log successful validation (will log submission after forwarding)
    logFormSubmission(formType, email, ip, userAgent, true)
    
    // Build sanitized form data for forwarding (all forms now use standard form data)
    const sanitizedFormBody = new URLSearchParams()
    for (const [key, value] of formData.entries()) {
      // Skip honeypot, recaptcha, and form-type fields (don't forward to Netlify)
      if (key === 'bot-field' || key === 'honeypot-1' || key === 'honeypot-2' || key === 'recaptcha-token' || key === 'form-type') {
        continue
      }
      // Use sanitized value if available, otherwise use original
      if (key in sanitizedData) {
        sanitizedFormBody.append(key, sanitizedData[key])
      } else {
        sanitizedFormBody.append(key, value)
      }
    }
    
    // Forward the sanitized submission to Netlify Forms (standard form data)
    const forwardResponse = await fetch(netlifyFormUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: sanitizedFormBody.toString(), // Forward sanitized form data
    })

    if (forwardResponse.ok) {
      // Success - send confirmation email to customer (fire and forget)
      // Don't block form submission if email fails
      try {
        const { sendConfirmationEmail } = require('./send-confirmation-email')
        
        // Convert formData to plain object for email template
        const emailFormData = {}
        for (const [key, value] of formData.entries()) {
          // Skip internal fields
          if (key === 'bot-field' || key === 'honeypot-1' || key === 'honeypot-2' || key === 'recaptcha-token' || key === 'form-type' || key === 'form-name') {
            continue
          }
          emailFormData[key] = value
        }
        
        // Send confirmation email asynchronously (don't await - fire and forget)
        sendConfirmationEmail(formType, emailFormData).catch(emailError => {
          // Log error but don't fail form submission
          console.error('‚ö†Ô∏è Failed to send confirmation email (non-blocking):', {
            formType,
            error: emailError.message || emailError
          })
        })
      } catch (emailSetupError) {
        // Log error but don't fail form submission
        console.error('‚ö†Ô∏è Error setting up confirmation email (non-blocking):', {
          formType,
          error: emailSetupError.message || emailSetupError
        })
      }
      
      // Success - return Netlify's response
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({ 
          success: true,
          message: 'Form submitted successfully'
        }),
      }
    } else {
      // Netlify Forms rejected it
      const errorText = await forwardResponse.text()
      console.error('Netlify Forms error:', {
        formType,
        status: forwardResponse.status,
        error: errorText
      })
      
      return {
        statusCode: 500,
        headers,
        body: JSON.stringify({ 
          error: 'Form submission failed',
          message: 'Unable to process your submission'
        }),
      }
    }

  } catch (error) {
    console.error('‚ùå Validation error:', {
      message: error.message,
      stack: error.stack,
      contentType: event.headers['content-type'] || event.headers['Content-Type'],
      bodyType: typeof event.body,
      bodyLength: event.body ? (Buffer.isBuffer(event.body) ? event.body.length : String(event.body).length) : 0,
      isBase64Encoded: event.isBase64Encoded,
      path: event.path
    })
    
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({ 
        error: 'Server error',
        message: 'An error occurred processing your request',
        details: process.env.NODE_ENV === 'development' ? error.message : undefined
      }),
    }
  }
}

