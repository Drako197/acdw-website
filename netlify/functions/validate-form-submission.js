/**
 * Generic Form Submission Validator
 * 
 * Server-side validation to prevent bot submissions
 * Validates before forwarding to Netlify Forms
 * 
 * Supports multiple form types: contact, hero-email, promo
 */

// Import utilities
const { checkRateLimit, getRateLimitHeaders, getClientIP } = require('./utils/rate-limiter')
const { sanitizeFormData, validateFile } = require('./utils/input-sanitizer')
const { 
  logFormSubmission, 
  logBotDetected, 
  logRecaptcha, 
  logRateLimit, 
  logInjectionAttempt,
  EVENT_TYPES 
} = require('./utils/security-logger')
const { parseMultipartFormData } = require('./utils/parse-multipart')

// reCAPTCHA verification
const RECAPTCHA_SECRET_KEY = process.env.RECAPTCHA_SECRET_KEY

/**
 * Verify reCAPTCHA token with Google
 */
const verifyRecaptcha = async (token) => {
  if (!RECAPTCHA_SECRET_KEY) {
    console.warn('reCAPTCHA secret key not configured - skipping verification')
    return { success: false, score: 0, error: 'Not configured' }
  }

  try {
    const response = await fetch('https://www.google.com/recaptcha/api/siteverify', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        secret: RECAPTCHA_SECRET_KEY,
        response: token
      }).toString()
    })

    const data = await response.json()
    return {
      success: data.success || false,
      score: data.score || 0,
      action: data.action || '',
      challenge_ts: data.challenge_ts,
      hostname: data.hostname,
      'error-codes': data['error-codes'] || []
    }
  } catch (error) {
    console.error('reCAPTCHA verification error:', error)
    return { success: false, score: 0, error: error.message }
  }
}

/**
 * Validate email format
 */
const validateEmail = (email) => {
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/
  const trimmedEmail = email?.trim() || ''
  
  if (!trimmedEmail) {
    return { valid: false, error: 'Email is required' }
  }
  
  if (!emailRegex.test(trimmedEmail)) {
    return { valid: false, error: 'Invalid email format' }
  }
  
  return { valid: true, email: trimmedEmail }
}

/**
 * Validate form-specific fields
 */
const validateFormFields = (formType, formData) => {
  const errors = []
  
  // Handle contact form subtypes (contact-general, contact-support, contact-sales, contact-installer, contact-demo)
  if (formType.startsWith('contact-')) {
    const contactSubType = formType.replace('contact-', '')
    const firstName = formData.get('firstName')?.trim() || ''
    const lastName = formData.get('lastName')?.trim() || ''
    const message = formData.get('message')?.trim() || ''
    
    // Common fields for all contact forms
    if (!firstName) errors.push('First name is required')
    if (!lastName) errors.push('Last name is required')
    if (!message) errors.push('Message is required')
    if (message && message.length > 2000) {
      errors.push('Message must be 2000 characters or less')
    }
    
    // Form-specific required fields
    switch (contactSubType) {
      case 'support':
        // Support form requires: product, issueType
        const product = formData.get('product')?.trim() || ''
        const issueType = formData.get('issueType')?.trim() || ''
        if (!product) errors.push('Product is required')
        if (!issueType) errors.push('Issue type is required')
        break
        
      case 'sales':
        // Sales form requires: company, role, interest
        const company = formData.get('company')?.trim() || ''
        const role = formData.get('role')?.trim() || ''
        const interest = formData.get('interest')?.trim() || ''
        if (!company) errors.push('Company is required')
        if (!role) errors.push('Role is required')
        if (!interest) errors.push('Interest type is required')
        break
        
      case 'installer':
        // Installer form requires: location, productToInstall
        const location = formData.get('location')?.trim() || ''
        const productToInstall = formData.get('productToInstall')?.trim() || ''
        if (!location) errors.push('Location is required')
        if (!productToInstall) errors.push('Product to install is required')
        break
        
      case 'demo':
        // Demo form requires: company, demoType, city, state, zip, numberOfAttendees, productsOfInterest
        const demoCompany = formData.get('company')?.trim() || ''
        const demoType = formData.get('demoType')?.trim() || ''
        const demoCity = formData.get('city')?.trim() || ''
        const demoState = formData.get('state')?.trim() || ''
        const demoZip = formData.get('zip')?.trim() || ''
        const numberOfAttendees = formData.get('numberOfAttendees')?.trim() || ''
        const productsOfInterest = formData.get('productsOfInterest')?.trim() || ''
        if (!demoCompany) errors.push('Company is required')
        if (!demoType) errors.push('Demo type is required')
        if (!demoCity) errors.push('City is required')
        if (!demoState) errors.push('State is required')
        if (!demoZip) errors.push('ZIP code is required')
        if (demoZip && !/^\d{5}$/.test(demoZip)) {
          errors.push('ZIP code must be 5 digits')
        }
        if (!numberOfAttendees) errors.push('Number of attendees is required')
        if (!productsOfInterest) errors.push('At least one product of interest is required')
        break
        
      case 'upgrade':
        // Core 1.0 upgrade form requires: firstName, lastName, email, phone, street, city, state, zip, consent, photo
        const upgradeFirstName = formData.get('firstName')?.trim() || ''
        const upgradeLastName = formData.get('lastName')?.trim() || ''
        const upgradeEmail = formData.get('email')?.trim() || ''
        const upgradePhone = formData.get('phone')?.trim() || ''
        const upgradeStreet = formData.get('street')?.trim() || ''
        const upgradeCity = formData.get('city')?.trim() || ''
        const upgradeState = formData.get('state')?.trim() || ''
        const upgradeZip = formData.get('zip')?.trim() || ''
        const upgradeConsent = formData.get('consent')
        const upgradePhoto = formData.get('photo')
        
        if (!upgradeFirstName) errors.push('First name is required')
        if (!upgradeLastName) errors.push('Last name is required')
        if (!upgradeEmail) {
          errors.push('Email is required')
        } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(upgradeEmail)) {
          errors.push('Invalid email format')
        }
        if (!upgradePhone) errors.push('Phone is required')
        if (!upgradeStreet) errors.push('Street address is required')
        if (!upgradeCity) errors.push('City is required')
        if (!upgradeState) errors.push('State is required')
        if (!upgradeZip) {
          errors.push('ZIP code is required')
        } else if (!/^\d{5}$/.test(upgradeZip)) {
          errors.push('ZIP code must be 5 digits')
        }
        if (!upgradeConsent || upgradeConsent !== 'yes') {
          errors.push('You must acknowledge the terms to continue')
        }
        if (!upgradePhoto || upgradePhoto.size === 0) {
          errors.push('Photo is required')
        } else {
          // Check file size (5MB limit)
          const maxSize = 5 * 1024 * 1024 // 5MB in bytes
          if (upgradePhoto.size > maxSize) {
            errors.push('File size must be 5MB or less')
          }
        }
        break
        
      case 'general':
        // General form - no additional required fields beyond common ones
        break
        
      default:
        console.warn(`Unknown contact form subtype: ${contactSubType}`)
    }
  } else {
    // Handle other form types
    switch (formType) {
      case 'hero-email':
      case 'promo':
        // Email-only forms - email validation handled separately
        break
        
      case 'unsubscribe':
        // Unsubscribe form requires: email, reason (optional but must be valid if provided)
        const unsubscribeReason = formData.get('reason')?.trim() || ''
        if (unsubscribeReason) {
          // SECURITY: Validate dropdown value - prevent malformed email injection
          const ALLOWED_UNSUBSCRIBE_REASONS = [
            'too-many-emails',
            'not-relevant',
            'never-signed-up',
            'other'
          ]
          
          if (!ALLOWED_UNSUBSCRIBE_REASONS.includes(unsubscribeReason)) {
            // Check if reason looks like a malformed email (bot attack pattern)
            if (unsubscribeReason.includes('-') && !unsubscribeReason.includes('@')) {
              errors.push('Invalid reason selected - suspicious pattern detected')
              console.warn('üö® Bot attack detected: Malformed email in unsubscribe reason field', {
                reason: unsubscribeReason,
                ip: getClientIP ? getClientIP(event) : 'unknown'
              })
            } else {
              errors.push('Invalid reason selected')
            }
          }
        }
        break
        
      case 'email-preferences':
        // Email preferences form - email validation handled separately
        break
        
      default:
        console.warn(`Unknown form type: ${formType}`)
    }
  }
  
  return errors
}

exports.handler = async (event, context) => {
  const headers = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'DENY',
    'X-XSS-Protection': '1; mode=block',
    'Referrer-Policy': 'strict-origin-when-cross-origin',
    'Permissions-Policy': 'geolocation=(), microphone=(), camera=()',
    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
  }

  // Handle CORS preflight
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers,
      body: '',
    }
  }

  // Only allow POST requests
  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: 'Method not allowed' }),
    }
  }

  try {
    // SECURITY: Check if this is a webhook endpoint (exempt from some validations)
    const isWebhookEndpoint = (path) => {
      return path && (path.includes('stripe-webhook') || path.includes('webhook'))
    }
    
    const isCheckoutEndpoint = (path) => {
      return path && (path.includes('create-checkout') || path.includes('get-checkout-session') || path.includes('get-price-id'))
    }
    
    const path = event.path || ''
    
    // Parse form data - handle both multipart/form-data and application/x-www-form-urlencoded
    const contentType = event.headers['content-type'] || event.headers['Content-Type'] || ''
    let formData
    let fileData = {} // Store file data for multipart forms
    
    if (contentType.includes('multipart/form-data')) {
      // For multipart/form-data (file uploads), parse using busboy
      try {
        const { fields, files } = await parseMultipartFormData(event)
        
        // Create a formData-like object for validation
        formData = {
          get: (key) => {
            if (fields[key] !== undefined) return fields[key]
            if (files[key]) return files[key]
            return null
          },
          entries: function* () {
            for (const [key, value] of Object.entries(fields)) {
              yield [key, value]
            }
            for (const [key, file] of Object.entries(files)) {
              yield [key, file]
            }
          }
        }
        
        fileData = files // Store files for later forwarding to Netlify Forms
      } catch (error) {
        console.error('‚ùå Error parsing multipart form data:', {
          error: error.message,
          stack: error.stack,
          contentType,
          bodyType: typeof event.body,
          bodyLength: event.body ? (Buffer.isBuffer(event.body) ? event.body.length : String(event.body).length) : 0,
          isBase64Encoded: event.isBase64Encoded
        })
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({ 
            error: 'Invalid form data format',
            message: 'Unable to parse form submission. Please try again.',
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
          }),
        }
      }
    } else {
      // For application/x-www-form-urlencoded, use URLSearchParams
      formData = new URLSearchParams(event.body)
    }
    
    // Get form name and type
    const formName = formData.get('form-name') || ''
    const formType = formData.get('form-type') || 'contact'
    
    // SECURITY: Form name whitelist validation (only allow known form names)
    const ALLOWED_FORM_NAMES = [
      'contact-general',
      'contact-support',
      'contact-sales',
      'contact-installer',
      'contact-demo',
      'email-preferences',
      'unsubscribe',
      'promo-signup',
      'core-upgrade',
      'hero-email'
    ]
    
    // Only validate form name if this is a form submission (not a webhook or checkout endpoint)
    if (!isWebhookEndpoint(path) && !isCheckoutEndpoint(path)) {
      if (formName && !ALLOWED_FORM_NAMES.includes(formName)) {
        console.warn('‚ùå Invalid form name rejected:', {
          formName,
          ip: getClientIP(event),
          userAgent: event.headers['user-agent'] || 'unknown',
          path
        })
        logBotDetected(formType, 'invalid-form-name', getClientIP(event), event.headers['user-agent'] || 'unknown', {
          formName,
          allowedNames: ALLOWED_FORM_NAMES
        })
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({ 
            error: 'Invalid form name',
            message: 'Form submission rejected'
          }),
        }
      }
    }
    
    // SECURITY: Origin/Referer validation (exempt webhooks and checkout endpoints)
    if (!isWebhookEndpoint(path) && !isCheckoutEndpoint(path)) {
      const ALLOWED_ORIGINS = [
        'https://www.acdrainwiz.com',
        'https://acdrainwiz.com'
      ]
      
      const origin = event.headers.origin || event.headers.referer || ''
      const isValidOrigin = !origin || ALLOWED_ORIGINS.some(allowed => origin.startsWith(allowed))
      
      if (!isValidOrigin) {
        console.warn('‚ùå Invalid origin rejected:', {
          origin,
          ip: getClientIP(event),
          userAgent: event.headers['user-agent'] || 'unknown',
          path
        })
        logBotDetected(formType, 'invalid-origin', getClientIP(event), event.headers['user-agent'] || 'unknown', {
          origin,
          allowedOrigins: ALLOWED_ORIGINS
        })
        return {
          statusCode: 403,
          headers,
          body: JSON.stringify({ 
            error: 'Invalid origin',
            message: 'Request rejected'
          }),
        }
      }
    }
    
    // SECURITY: User-Agent validation (exempt webhooks)
    if (!isWebhookEndpoint(path)) {
      const BOT_USER_AGENTS = [
        'curl',
        'wget',
        'python-requests',
        'go-http-client',
        'java/',
        'scrapy',
        'bot',
        'crawler',
        'spider',
        'httpie',
        'postman'
      ]
      
      const userAgent = event.headers['user-agent'] || ''
      const isBotUserAgent = BOT_USER_AGENTS.some(bot => userAgent.toLowerCase().includes(bot.toLowerCase()))
      
      if (isBotUserAgent) {
        console.warn('‚ùå Bot user agent rejected:', {
          userAgent,
          ip: getClientIP(event),
          path
        })
        logBotDetected(formType, 'bot-user-agent', getClientIP(event), userAgent, {
          userAgent,
          detectedBots: BOT_USER_AGENTS.filter(bot => userAgent.toLowerCase().includes(bot.toLowerCase()))
        })
        return {
          statusCode: 403,
          headers,
          body: JSON.stringify({ 
            error: 'Bot detected',
            message: 'Request rejected'
          }),
        }
      }
    }
    
    // Get honeypot fields (field names may vary by form)
    const botField = formData.get('bot-field') || formData.get('website') || formData.get('url') || ''
    const honeypot1 = formData.get('honeypot-1') || ''
    const honeypot2 = formData.get('honeypot-2') || ''
    
    // Get reCAPTCHA token
    const recaptchaToken = formData.get('recaptcha-token') || ''
    
    // Get email for validation (before sanitization)
    const rawEmail = formData.get('email') || ''
    
    // Get request metadata for logging
    const ip = getClientIP(event)
    const userAgent = event.headers['user-agent'] || 'unknown'

    // Rate limiting check
    const rateLimitType = formType === 'upgrade' ? 'strict' : 'form'
    const rateLimitResult = checkRateLimit(ip, rateLimitType)
    
    if (!rateLimitResult.allowed) {
      logRateLimit(ip, rateLimitType, rateLimitResult.limit, rateLimitResult.remaining, true)
      
      return {
        statusCode: 429,
        headers: {
          ...headers,
          ...getRateLimitHeaders(rateLimitResult)
        },
        body: JSON.stringify({
          success: false,
          error: 'Too many requests. Please try again later.',
          retryAfter: rateLimitResult.retryAfter
        })
      }
    }

    // Sanitize all text inputs (convert FormData to object for sanitization)
    const formDataObj = {}
    for (const [key, value] of formData.entries()) {
      // Skip file fields - they're handled separately
      if (key === 'photo' || value instanceof File || value instanceof Blob) {
        formDataObj[key] = value
      } else {
        formDataObj[key] = String(value || '')
      }
    }
    
    // Sanitize form data
    const sanitizedData = sanitizeFormData(formDataObj, formType)
    
    // Get sanitized email for validation
    const email = sanitizedData.email || rawEmail

    // Validation errors array
    const errors = []
    
    // 0. Verify reCAPTCHA token (if provided and configured)
    let recaptchaResult = null
    if (recaptchaToken) {
      recaptchaResult = await verifyRecaptcha(recaptchaToken)
      
      if (!recaptchaResult.success) {
        logRecaptcha(false, 0, recaptchaResult.action, ip, userAgent, recaptchaResult['error-codes'])
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({ 
            error: 'Security verification failed',
            message: 'Please refresh and try again'
          }),
        }
      }
      
      // Check score (0.0 = bot, 1.0 = human)
      const scoreThreshold = parseFloat(process.env.RECAPTCHA_SCORE_THRESHOLD || '0.5')
      if (recaptchaResult.score < scoreThreshold) {
        logRecaptcha(true, recaptchaResult.score, recaptchaResult.action, ip, userAgent)
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({ 
            error: 'Suspicious activity detected',
            message: 'Please try again'
          }),
        }
      }
      
      logRecaptcha(true, recaptchaResult.score, recaptchaResult.action, ip, userAgent)
    } else if (RECAPTCHA_SECRET_KEY) {
      // Token missing but reCAPTCHA is configured
      console.warn('‚ö†Ô∏è reCAPTCHA token missing (but configured)', {
        formType,
        ip,
        userAgent,
        email: email ? email.substring(0, 3) + '***' : 'none' // SECURITY: Only log first 3 chars
      })
      // Graceful degradation - allow but log
    }

    // 1. Check honeypot fields (if filled, it's a bot)
    if (botField || honeypot1 || honeypot2) {
      logBotDetected(formType, 'honeypot', ip, userAgent, {
        botField: !!botField,
        honeypot1: !!honeypot1,
        honeypot2: !!honeypot2,
      })
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ 
          error: 'Invalid submission',
          message: 'Bot detected'
        }),
      }
    }

    // 2. Validate email format
    const emailValidation = validateEmail(email)
    if (!emailValidation.valid) {
      errors.push(emailValidation.error)
    }

    // 3. Validate form-specific fields (using original formData for validation)
    // Validation happens on original data, but we'll forward sanitized data
    const formErrors = validateFormFields(formType, formData)
    errors.push(...formErrors)
    
    // SECURITY: Additional validation for unsubscribe form - dropdown value validation
    if (formType === 'unsubscribe' || formName === 'unsubscribe') {
      const unsubscribeReason = formData.get('reason')?.trim() || ''
      if (unsubscribeReason) {
        const ALLOWED_UNSUBSCRIBE_REASONS = [
          'too-many-emails',
          'not-relevant',
          'never-signed-up',
          'other'
        ]
        
        if (!ALLOWED_UNSUBSCRIBE_REASONS.includes(unsubscribeReason)) {
          // Check if reason looks like a malformed email (bot attack pattern)
          if (unsubscribeReason.includes('-') && !unsubscribeReason.includes('@') && unsubscribeReason.length > 10) {
            errors.push('Invalid reason selected - suspicious pattern detected')
            console.warn('üö® Bot attack detected: Malformed email in unsubscribe reason field', {
              reason: unsubscribeReason,
              formName,
              ip,
              userAgent
            })
            logBotDetected(formType, 'malformed-email-in-dropdown', ip, userAgent, {
              reason: unsubscribeReason,
              formName,
              allowedReasons: ALLOWED_UNSUBSCRIBE_REASONS
            })
          } else {
            errors.push('Invalid reason selected')
          }
        }
      }
    }

    // 4. Check for suspicious patterns
    if (email && !email.includes('@')) {
      errors.push('Invalid email format')
    }

    // If validation failed, reject
    if (errors.length > 0) {
      // SECURITY: Don't log full email - only log first 3 characters for debugging
      const emailPrefix = email ? email.substring(0, 3) + '***' : 'none'
      console.warn('‚ùå Validation failed:', {
        formType,
        errors,
        email: emailPrefix, // Sanitized - only first 3 chars
        ip,
        userAgent
      })
      
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ 
          error: 'Validation failed',
          errors: errors
        }),
      }
    }

    // 5. If validation passed, forward sanitized data to Netlify Forms
    const netlifyFormUrl = event.headers.host 
      ? `https://${event.headers.host}/`
      : 'https://acdrainwiz.com/'
    
    // Log successful validation (will log submission after forwarding)
    logFormSubmission(formType, email, ip, userAgent, true)
    
    // Build sanitized form data for forwarding
    const requestContentType = event.headers['content-type'] || event.headers['Content-Type'] || ''
    let forwardResponse
    
    if (requestContentType.includes('multipart/form-data')) {
      // For multipart forms (with file uploads), rebuild FormData
      try {
        const FormData = require('form-data')
        const formDataToForward = new FormData()
        
        // Add all fields
        for (const [key, value] of formData.entries()) {
          // Skip honeypot and recaptcha fields (don't forward to Netlify)
          if (key === 'bot-field' || key === 'honeypot-1' || key === 'honeypot-2' || key === 'recaptcha-token') {
            continue
          }
          
          // Handle file uploads
          if (fileData[key]) {
            const file = fileData[key]
            formDataToForward.append(key, file.data, {
              filename: file.filename,
              contentType: file.mimeType
            })
          } else {
            // Use sanitized value if available, otherwise use original
            const valueToUse = sanitizedData[key] !== undefined ? sanitizedData[key] : value
            // Only append if value is a string (not a file object)
            if (typeof valueToUse === 'string') {
              formDataToForward.append(key, valueToUse)
            }
          }
        }
        
        // Forward multipart form data
        // form-data library returns a readable stream that fetch() can handle directly
        const formDataHeaders = formDataToForward.getHeaders()
        
        forwardResponse = await fetch(netlifyFormUrl, {
          method: 'POST',
          headers: formDataHeaders,
          body: formDataToForward
        }).catch(fetchError => {
          console.error('‚ùå Fetch error when forwarding multipart:', {
            error: fetchError.message,
            stack: fetchError.stack,
            formType,
            headers: formDataHeaders
          })
          throw fetchError
        })
      } catch (forwardError) {
        console.error('‚ùå Error forwarding multipart form to Netlify:', {
          error: forwardError.message,
          stack: forwardError.stack,
          formType
        })
        return {
          statusCode: 500,
          headers,
          body: JSON.stringify({ 
            error: 'Form submission failed',
            message: 'Unable to forward form data to Netlify Forms'
          }),
        }
      }
    } else {
      // For application/x-www-form-urlencoded, use URLSearchParams
      const sanitizedFormBody = new URLSearchParams()
      for (const [key, value] of formData.entries()) {
        // Skip honeypot and recaptcha fields (don't forward to Netlify)
        if (key === 'bot-field' || key === 'honeypot-1' || key === 'honeypot-2' || key === 'recaptcha-token') {
          continue
        }
        // Use sanitized value if available, otherwise use original
        if (key in sanitizedData) {
          sanitizedFormBody.append(key, sanitizedData[key])
        } else {
          sanitizedFormBody.append(key, value)
        }
      }
      
      // Forward the sanitized submission to Netlify Forms
      forwardResponse = await fetch(netlifyFormUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: sanitizedFormBody.toString(), // Forward sanitized form data
      })
    }

    if (forwardResponse.ok) {
      // Success - return Netlify's response
      return {
        statusCode: 200,
        headers,
        body: JSON.stringify({ 
          success: true,
          message: 'Form submitted successfully'
        }),
      }
    } else {
      // Netlify Forms rejected it
      const errorText = await forwardResponse.text()
      console.error('Netlify Forms error:', {
        formType,
        status: forwardResponse.status,
        error: errorText
      })
      
      return {
        statusCode: 500,
        headers,
        body: JSON.stringify({ 
          error: 'Form submission failed',
          message: 'Unable to process your submission'
        }),
      }
    }

  } catch (error) {
    console.error('‚ùå Validation error:', {
      message: error.message,
      stack: error.stack,
      contentType: event.headers['content-type'] || event.headers['Content-Type'],
      bodyType: typeof event.body,
      bodyLength: event.body ? (Buffer.isBuffer(event.body) ? event.body.length : String(event.body).length) : 0,
      isBase64Encoded: event.isBase64Encoded,
      path: event.path
    })
    
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({ 
        error: 'Server error',
        message: 'An error occurred processing your request',
        details: process.env.NODE_ENV === 'development' ? error.message : undefined
      }),
    }
  }
}

